#! /bin/bash

# use bash -x ./photo_downloader to run in debug mode or uncomment the following:
# set -x

backup_drive_label='Backup_Data'
camera_name='OLYMPUS_E-30'
camera_dir='/DCIM/100OLYMP/'
working_dir='/home/My Home/My Pictures/'
backup_dir='/My Pictures/'
image_types='ORF JPG jpg'
exiftool_date_pattern='%Y/raw images/%m %b/%Y_%m_%d/'

if [[ ${1} == "test"  ]]
	then
		echo testing
		camera_dir=./DCIM/100OLYMP/
		working_dir=./working/
		backup_dir=./backup/
fi

function variable_print_outs ()
{
	echo from line $1
	echo loop$loops.line$LINENO "$camera_dir"*."$filename_extension"
	echo loop$loops.line$LINENO "$target_string"
	echo loop$loops.line$LINENO "${target_array[loop2]}"
	echo loop$loops.line$LINENO "$loop2"
	echo loop$loops.line$LINENO "$camera_dir"${target_array[loop2]} "$working_dir"${target_array[((loop2+1))]}${target_array[loop2]}
	echo loop$loops.line$LINENO "$camera_dir"${target_array[loop2]} "$backup_dir"${target_array[((loop2+1))]}${target_array[loop2]}
	echo $'\n'
}


if [[ $(findmnt -n -o target /dev/disk/by-id/*"$camera_name"*part1) ]]
	then
		echo "$camera_name" camera is attached
	else
		echo "$camera_name" camera is not attached, exiting
		if [[ ${1} == "test" ]]
			then
				echo testing
				echo continuing with test directories
			else
				exit
		fi
fi

if [[ $(findmnt -n -o target /dev/disk/by-label/"$backup_drive_label") ]]
	then
		echo "$backup_drive_label" disk is mounted
	else
		echo "$backup_drive_label" is not mounted
		if [[ ${1} == "test" ]]
			then
				echo testing
				echo continuing with test directories
			else
				udisksctl mount -b /dev/disk/by-label/"$backup_drive_label"
		fi
fi

camera_dir=$(findmnt -n -o target /dev/disk/by-id/*"$camera_name"*part1)"$camera_dir"
backup_dir=$(findmnt -n -o target /dev/disk/by-label/"$backup_drive_label")"$backup_dir"
loop1=1000; loop2=0

echo Settings$'\n' backup_drive_label$'\t'"$backup_drive_label"$'\n' camera_name$'\t'$'\t'"$camera_name"$'\n' camera_dir$'\t'$'\t'"$camera_dir"$'\n' working_dir$'\t'$'\t'"$working_dir"$'\n' backup_dir$'\t'$'\t'"$backup_dir"$'\n' exiftool_date_pattern$'\t'"$exiftool_date_pattern"$'\n' image_types$'\t'$'\t'"$image_types"$'\n'

for filename_extension in $image_types
do

#	variable_print_outs "$LINENO"

	for files in "$camera_dir"*."$filename_extension"
	do
		[[ -a  "$files" ]] && { echo $'\n'file extension $filename_extension exists on camera$'\n'; break; } || { echo $'\n'file extension $filename_extension does not exist on camera$'\n'; break 2; }
	done

	old_IFS=$IFS; IFS=,$'\n'
	target_string=$(exiftool -p '${filename},${datetimeoriginal}' -d '%Y/raw images/%m %b/%Y_%m_%d/' $camera_dir*."$filename_extension")
	target_array=($target_string)

	echo ${*}; sleep 2

	while  ((loop2<${#target_array[*]}))
	do
		loops=$(($loop1+$loop2))

		echo -en '\e[2K'

		if [[ ${*} == *"--rsynca"* ]]
			then
				echo -e '\eM - approach a 1st rsync in {}&'
				{ rsync --mkpath --info=name2 -ah "$camera_dir"${target_array[loop2]} "$working_dir"${target_array[((loop2+1))]}${target_array[loop2]} | tr '\n' '\r'; }&
				rsync --mkpath --info=name2 -ah "$camera_dir"${target_array[loop2]} "$backup_dir"${target_array[((loop2+1))]}${target_array[loop2]} | tr '\n' '\r'
				wait
			elif [[ ${*} == *"--rsyncb"* ]]
				then
					echo -e '\eM - approach b 1st rsync in ()&'
					( rsync --mkpath --info=name2 -ah "$camera_dir"${target_array[loop2]} "$working_dir"${target_array[((loop2+1))]}${target_array[loop2]} | tr '\n' '\r'; )&
					rsync --mkpath --info=name2 -ah "$camera_dir"${target_array[loop2]} "$backup_dir"${target_array[((loop2+1))]}${target_array[loop2]} | tr '\n' '\r'
					wait
			elif [[ ${*} == *"--rsyncc"* ]]
				then
					echo -e '\eM - approach c 1st rsync terminated with &'
					rsync --mkpath --info=name2 -ah "$camera_dir"${target_array[loop2]} "$working_dir"${target_array[((loop2+1))]}${target_array[loop2]} | tr '\n' '\r'&
					rsync --mkpath --info=name2 -ah "$camera_dir"${target_array[loop2]} "$backup_dir"${target_array[((loop2+1))]}${target_array[loop2]} | tr '\n' '\r'
					wait
			elif [[ ${*} == *"--rsyncd"* ]]
				then
					echo -e '\eM - approach d both rsync grouped in {} terminated with & no wait command'
					{ rsync --mkpath --info=name2 -ah "$camera_dir"${target_array[loop2]} "$working_dir"${target_array[((loop2+1))]}${target_array[loop2]} | tr '\n' '\r' }&
					{ rsync --mkpath --info=name2 -ah "$camera_dir"${target_array[loop2]} "$backup_dir"${target_array[((loop2+1))]}${target_array[loop2]} | tr '\n' '\r' }&
				else
				echo -e '\eM - no  parallel'
				rsync --mkpath --info=name2 -ah "$camera_dir"${target_array[loop2]} "$working_dir"${target_array[((loop2+1))]}${target_array[loop2]} | tr '\n' '\r'
				rsync --mkpath --info=name2 -ah "$camera_dir"${target_array[loop2]} "$backup_dir"${target_array[((loop2+1))]}${target_array[loop2]} | tr '\n' '\r'
		fi

		camera_file_list[$loops]="$(find "$camera_dir" -name "${target_array[loop2]}")"$'\n'
		working_file_list[$loops]="$(find "$working_dir""$target_dir" -name "${target_array[loop2]}")"$'\n'
		backup_file_list[$loops]="$(find "$backup_dir""$target_dir" -name "${target_array[loop2]}")"$'\n'

		((loop2+=2))

	done

	echo ''
	IFS=$old_IFS
	((loop1+=1000)); loop2=0
done

echo camera file list:$'\n' "${camera_file_list[*]##"$camera_dir"}" ${#camera_file_list[*]} files
echo working file list:$'\n' "${working_file_list[*]}" ${#working_file_list[*]} files
echo backup file list:$'\n' "${backup_file_list[*]}" ${#backup_file_list[*]} files


#************************************************************************************************************
# COMMENTS
#***********************************************************************************************************
#   1)	SPECIFIES THE INTERPRETER AND ITS LOCATION FOR THE SCRIPT
#   3)	set BUILTIN MODIFIES SHELL BEHAVIOUR OR DISPLAYS NAMES AND VALUES OF SHELL VARIABLES. set -x OR set -o xtrace EQUIVALENT TO bash -x ./photo_downloader PRINTS A TRACE OF COMMANDS AND ARITHMATIC AND EXPANSIONS BEFORE EXECUTION FOR DEBUGGING
#   6-12)	PLACED VARIABLE ASSIGNMENTS TOGETHER HERE TO ALLOW EASY CUSTOMISATION EDITING OR POSSIBLE INTERACTIVE SCRIPT CHOICE SAY FOR CAMERA ID. mUST BE QUOTED TO ALLOW FOR SPACES IN NAMES (NO WORD SPLITTING) '' PRESERVES THE LITERAL VALUE "" PRESERVES THE LITERAL VALUE EXCEPT FOR $'|! CHARACTERS. THE SPECIAL PARAMETERS * AND @ CREATE LISTS OF POSITIONAL PARAMETERS IF QUOTED
#   6)	LABEL OF THE DRIVE TO MOUNT AND SEND THE BACKUP COPY TO, LABEL WAS THE EASIEST WAY TO CONSISTANTLY MOUNT DRIVE AND FIND THE MOUNT POINT ls /dev/disk/by-label/*
#   7)	THE NAME OF THE CAMERA FOUND BY PLUGING IN CAMERA AND AFTER AUTO MOUNT EXECUTING ls /dev/disk/by-id/*
#   8)	THE DIRECTORY STRUCTURE ON THE CAMERA'S MEMORY CARD, OLYMPUS USE /DCIM/100OLYMP
#   9)	THE DIRECTORY ON ~/home WHERE FILES TO BE PROCESSED WILL BE LOCATED
#  10)	THE DIRECTORY ON /media WHERE FILES TO BE ARCHIVED WILL BE LOCATED
#  11)	THE IMAGE FILE EXTENSIONS TO BE SEARCHED FOR AND DOWNLOADED FROM THE CAMERA
#  12)	PATTERN FOR exiftool -d DATE FORMAT OPTION USING strftime SYNTAX WHICH ULTIMATELY CREATES DATE BASED FOLDER STRUCTURE TO STORE IMAGES WHERE
#				%Y = YEAR AS DECIMAL INCLUDING CENTURY ie 2024
#				%m = MONTH AS DECIMAL ie 04
#				%b = MONTH AS SHORT STRING ie APR
#				%d = DAY OF THE MONTH AS DECIMAL ie 21
# RESULTING IN 2024/raw images/04 Apr/2024_04_21
#  14-20)	if CONDITIONAL TO CHANGE camera_dir, working_dir and backup_dir TO A TESTING SETUP IF THE ARGUMENT 'test' IS PASSED INTO THE POSITIONAL PARAMETER ${1} ie ./photo_downloader test
#  22-33)	A FUNCTION TO PRINT OUT A LIST OF GLOBAL VARIABLES (BEFORE I FOUND set -x) TO HELP DEBUG / UNDERSTAND BASH AND TEST VARIABLE COMBINATIONS, EXPANSIONS AND SUBSTITUTIONS. COULD ALSO USE declare -p NAME WHERE -p	DISPLAY THE ATTRIBUTES AND VALUE OF EACH NAME
#		declare -p camera_dir
#			declare -- camera_dir="/media/$USER/OLY_E-30/media/$USER/OLY_E-30/DCIM/100OLYMP/"
#  22)	LONGHAND OPENING FOR FUNCTION
#  24)	PRINT OUT LINE NUMBER THE FUNCTION WAS CALLED FROM USING POSITIONAL PARAMETER $1 WHICH CONTAINS THE FIRST ARGUMENT PASSED TO THE FUNCTION IN THE CALL ie variable_print_outs <argument1>
#  25)  PRINTS OUT THE LOOP VARIABLE COUNTER AND BASH VARIABLE $LINENO WHICH RETURNS THE LINE NUMBER OF THE CURRENT COMMAND IN THE SCRIPT AND THE LIST OF FILES ON THE CAMERA WITH THE SELECTED EXTENSION ie /DCIM/100OLYMP/P421001.ORF /DCIM/100OLYMP/P421002.ORF etc
#  26)	PRINTS OUT THE VARIABLE FOR THE LIST OF FILES WITH PATHS TO BE WRITTEN
#  27)  PRINTS OUT THE ARRAY VALUE FOR TARGET FILE WITH PATH AT THE CURRENT LOOP POINT
#  28)  PRINTS OUT THE VALUE OF $loop2
#  29)  PRINTS OUT THE VALUE OF THE CURRENT LOOPS TARGET FILE WITH PATH ON THE CAMERA AND THE TARGET ON WORKING DIRECTORY
#  30)  PRINTS OUT THE VALUE OF THE CURRENT LOOPS TARGET FILE WITH PATH ON THE CAMERA AND THE TARGET ON BACKUP DIRECTORY
#  31)  PRINTS OUT A BLANK LINE USING $'\n' NEWLINE ANSI-C QUOTE CHARACTER
#  35-47)	if; then; else; fi CONDITIONAL TO DETECT CAMERA AND EXIT SCRIPT IF NOT FOUND
#  35)	findmnt FINDS A MOUNTED FILESYSTEM WHERE -n, --noheadings IS DON'T PRINT COLUMN HEADINGS AND -o, --output IS THE OUTPUT COLUMNS TO BE SHOWN, IN THIS CASE target.
#		findmnt -n -o target /dev/sdc1
#			/media/$USER/OLY_E-30
#		[[ /media/$USER/OLY_E30 ]]
#			success OR error
#  36)	IF THE CONDITIONAL IS TRUE then
#  37)	PRINT A MESSAGE CAMERA IS ATTACHED
#  38)	IF THE CONDITIONAL IS FALSE else
#  39)	PRINT A MESSAGE CAMERA IS NOT ATTACHED. EXITING
#  40-46)	if; then; else; fi conditional to setup testing environment
#  40)  if POSITIONAL PARAMETER ${1} IS EQUAL TO 'test' OBSERVE SPACING OR MATCHES ANY ARGUMENT PASSED
#  41)  if TRUE then
#  42-43)	echo testing messages
#  44)  else if NOT TRUE
#  45)  exit THE SCRIPT
#  46-47)	CLOSE if CONDITIONAL COMPOUND COMMANDS
#  49-62)	if; then; else; fi CONDITIONAL TO DETECT backup_data DRIVE AND MOUNT IF NESCESSARY. ORIGINALLY USED THE FOLLOWING
#		if [[ -n $(findmnt -n -o target $(readlink -f /dev/disk/by-label/"$backup_drive_label")) ]]
# WHERE readlink PRINTS THE VALUE OF A SYMBOLIC LINK OR CANONICAL (STANDARDISED) FILE NAME WHERE -f, --canonicalize IS CANONICALISE BY FOLLOWING EVERY SYMLINK IN EVERY COMPONENT OF THE GIVEN NAME RECURSIVELY; ALL BUT THE LAST COMPONENT MUST EXIST. findmnt FINDS A MOUNTED FILESYSTEM WHERE -n, --noheadings IS DON'T PRINT COLUMN HEADINGS AND -o, --output IS THE OUTPUT COLUMNS TO BE SHOWN, IN THIS CASE target.[[ expression ]] IS CONDITIONAL CONSTRUCT WHICH RETURNS A STATUS OF 0 OR 1 DEPENDING ON THE EVALAUATION OF expression. [[ -n string ]] IS A BASH CONDITIONAL EXPRESSION WHERE -n RETURNS true IF THE LENGTH OF THE STRING IS NON ZERO. EXIT OR RETURN STATUS IS 0 - SUCCESS OR NON ZERO - FAILURE. THIS SUPRESSES findmnt OUTPUT BY TESTING IF THE OUTPUT IS THERE OR NOT BUT THE -n, findmnt OPTIONS AND readlink ARE NOT NESCESSARY.
#  49)		findmnt /dev/disk/by-label/Backup_Data
#			[[ TARGET SOURCE FSTYPE OPTIONS /media/$USER/Backup_Data /dev/sdc ext4 rw,nosuid,nodev,relatime,errors=remount-ro ]] OR error
#			true OR error
#  50)	IF THE CONDITIONAL IS TRUE then
#  51)	PRINT A MESSAGE DISK IS MOUNTED
#  52)	IF THE CONDITIONAL IS FALSE else
#  53)  PRINT A MESSAGE DISK IS NOT MOUNTED
#  54-60)	if, then, else CONDITIONAL COMPOUND COMMANDS TO SET UP TESTING ENVIRONMENT
#  54)  if POSITIONAL PARAMETER ${1} IS EQUAL TO 'test'
#  55)  if TRUE then
#  56-57)	echo testing messages
#  58)  else if NOT TRUE
#  59)	USE udiskctl RATHER THAN mount BECAUSE THIS IS HOW NAUTILUS FILE MANAGER DOES IT, THE MOUNT WILL HAVE THE SAME DEFAULTS AND IT DOOES NOT NEED TO BE ROOT (REQUIRING USER PASSWORD) AS mount DOES. -b, --block-device THE BLOCK DEVICE TO MOUNT.
#		udiskctl mount -b /dev/disk/by-label/Backup_Data
#  60-61)	CLOSE IF CONDITIONL COMPOUND COMMANDS
#  63)	PREPEND THE MOUNTPOINT TO THE camera_dir VARIABLE USING findmnt
#		findmnt -n -o target /dev/disk/by-id/usb-"OLYMPUS_E-30"_G68508673-0:0-part1
#			/media/$USER/OLY_E-30
#		camera_dir=/media/$USER/OLY_E-30"/DCIM/100OLYMP/"
#  64)	PREPEND THE MOUNTPOINT TO THE backup_dir VARIABLE USING findmnt
#		findmnt -n -o target /dev/disk/by-label/"Backup_Data"
#			/media/$USER/Backup_Data
#		backup_dir=/media/$USER/Backup_Data"/My Pictures/"
#  65)	loop1 AND loop2 COUNT THE LOOPS FOR COPYING THE FILES. ORINGINALLY FOR TRACING IN THE FUNCTION variable_print_outs() BUT loop2 ALSO ALLOWS LIMITING SOME COMMANDS TO THE FIRST RUN OF THE LOOPS (LINE 55). SHELL ARITHMETIC REQUIRES INTEGERS IN ORDER TO CREATE A THIRD VARIABLE FOR THE COMBINED LOOP COUNT (loop) I STARTED loop1 AT 1000.
#  67)	PRINTS OUT THE VARIABLES
#		$backup_drive_label	=	Backup_Data
#		$camera_name		=	OLYMPUS_E-30
#		$camera_dir		=	/media/$USER/OLY_E-30/DCIM/100OLYMP/
#		$working_dir		=	/home/My Home/My Pictures/
#		$backup_dir		=	/media/$USER/Backup_Data/My Pictures/
#		$exiftool_date_pattern	=	%Y/raw images/%m %b/%Y_%m_%d/
#		$image_types		=	ORF JPG jpg
#  SEPERATED BY $'\n' NEWLINES OR $'\t' TAB SPACES
#  69-123)	THE NESTED for LOOPS TO CYCLE THROUGH THE LIST OF IMAGE TYPES SPECIFIED IN $image_types THEN CHECK IF THE FILE EXTENSION EXISTS ON CAMERA. A while LOOP THEN LOOPS THROUGH THE ARRAY OF FILENAMES AND PATHS SO rsync CAN COPY THE FILES TO BOTH THE DESTINATION FOLDERS. THE for LOOP EXECUTES COMMANDS ONCE FOR EACH MEMBER OF THE LIST WORDS WITH THE VARIABLE NAME TAKING THE VALUE OF THE WORD MATCHED FOR THAT RUN OF THE LOOP. THE WHILE LOOP EXECUTES COMMANDS WHILST A CONDITION IS NOT MET.
#		for NAME in WORDS; do COMMANDS; done
#		while CONDITION; do COMMANDS; done
#  69)	AT THE FIRST RUN OF THE LOOPS ie loop1 = 1000 AND loop2 = 1
#		for filename_extension in ORF JPG jpg
#			$filename_extension=ORF
#  72)	do COMMANDS WITHIN LOOP
#  73)	CALLS FUNCTION variable_print_outs WITH ARGUMENT "$LINENO" (THE BASH VARIABLE FOR THECURRENT LINE NUMBER OF THE SCRIPT WHICH BECOMES POSITIONAL PARAMETER $1 IN THE FUNCTION, IN THIS CASE 72
#  74)		for files in /media/$USER/OLY_E-30/DCIM/100OLYMP/*.ORF
#  ie A LIST OF ALL .ORF FILES IN 100OLYMP
#  		$camera_image_file=/media/$USER/OLY_E-30/DCIM/100OLYMP/P0421001.ORF
#  75-78)	PUT A CHECK IN TO SEE IF THIS IS THE FIRST RUN OF THE LOOP. IF YES THEN CHECK IF FILE EXISTS, IF NO BREAK OUT OF LOOP. WITHOUT THIS CHECK IF FILE DOES NOT EXIST THE STRING *.ORF ITSELF IS PASSED AND AN UNNESCESSARY RUN OF THE LOOP PERFORMED
#  75)	do COMMANDS WITHIN LOOP
#  76)	CONDITIONAL WHICH RETURNS A STATUS OF 0 SUCCESS OR 1 FAIL DEPENDANT ON THE EVALUATION OF [[ expression ]]. THE BASH CONDITIONAL EXPRESSION -a file RETURNS TRUE IF FILE EXISTS. THE PIPELINE OPERATORS && AND || ARE 'AND' AND 'OR' WHILST ; IS FOR THE CONSECUTIVE EXECUTION OF COMMANDS.
#		[[ -a /media/$USER/OLY_E-30/DCIM/100OLYMP/*.ORF ]]
#  RETURNS 0 (SUCCESS) WHEN FILE EXISTS ON CAMERA RETURNS 1 (FAIL) IF NOT
#  		&& { echo NEWLINE file extension ORF exists on camera NEWLINE; break; }
#  && (AND) PRINTS THE EXTENSION EXISTS AND BREAKS OUT OF THE LOOP
#		|| { echo NEWLINE file extension ORF does not exist on camera NEWLINE; break 2; }
#  || (OR) WHEN FILE DOES NOT EXIST, PRINTS FILE EXTENSION DOESNT EXIST MESSAGE AND BREAKS OUT OF 2 LOOP LEVELS.
#  THE COMMANDS AFTER ARE GROUPED TOGETHER WITH {} EXECUTING THE LIST OF COMMANDS AS A UNIT IN THE CURRENT SHELL CONTEXT NOT A SUBSHELL.
#  77)	CLOSE LOOP
#  79)	$IFS IS BOURNE SHELL VARIABLE CONTAINING A LIST OF CHARACTERS USED AS DELIMITERS TO SEPERATE FIELDS USED IN SHELL WORD SPLITTING AND EXPANSION, DEFAULT IS SPACE TAB NEWLINE. STORE THE CURRENT VALUE IN $old_IFS FOR EASY RESETTING THEN CHANGE $IFS TO COMMA AND NEWLINE.
#  80)	USE exiftool TO READ THE METADATA IN ALL THE IMAGE FILES OF THE CURRENT TYPE, AND PLACE THE -FileName AND -DateTimeOriginal TAGS SEPARATED BY COMAS IN target_string TO CREATE A DIRECTORY NAMING PATTERN. -p FMTFILE (-printFormat) Print output in specified format -d -dateformat USING strftime SYNTAX WHERE
#			%Y	-	YEAR AS DECIMAL INCLUDING CENTURY ie 2024
#			%m	-	MONTH AS DECIMAL ie 01
#			%b	-	MONTH AS SHORT STRING ie Jan
#			%d	-	DAY OF MONTH AS DECIMAL ie 01
#		exiftool -p  -d "%Y/raw images/%m %b/%Y_%m_%d/" -DateTimeOriginal "/media/$USER/OLY_E-30/DCIM/100OLYMP/P421001.ORF"
#		target_string="P421001.ORF,2024/raw images/04 Apr/2024_04_21/ NEWLINE P421002.ORF,2024/raw images/04 Apr/2024_04_21/" ETC
#  81)	CREATE AN ARRAY $target_array FROM $target_string ALLOWING THE SCRIPT TO ACCESS INDIVIDUAL ELEMENTS FILENAMES ARE EVEN STARTING AT 0, PATHS ARE ODD STARTING AT 1.
#  83)	PRINT THE SHELL SPECIAL PARAMETER WHICH EXPANDS TO THE POSITIONAL PARAMETERS AS SEPERATE WORDS STARTING FROM ONE WHEN NOT DOUBLE QUOTED. THEN SLEEP FOR 2 SECONDS AS THIS LINE GETS OVERWRITTEN.
#  85-121)	while LOOP TO READ CONTENTS OF ARRAY WHILE THE LOOP IS LESS THAN THE NUMBER OF ELEMENTS IN THE ARRAY AND rsync THE FILES. while CONDITION; do COMMANDS; done
#  85)	OPEN while LOOP. CONDITION TO TEST IS WHILE INNER LOOP COUNTER $loop2 IS LESS THAN THE NUMBER OF ELEMENTS IN $target_array
#  86)	do COMMANDS WITHIN LOOP
#  87)	USE ARITHMATIC EXPANSION AND SHELL ARITHMATIC TO COMBINE $loop1 AND $loop2 COUNTERS AND ASSIGN TO $loops. USED TO CREATE ARRAYS FROM find FILES COMMAND AND IN function variable_print_outs(). ie IF $loop1 = 1000 AND $loop2 = 2 THEN $loopS = 1002. BASH ONLY DOES INTEGER MATHS WHICH IS WHY loop1 STARTS AT 1000.
#  89)	PRINT A CLEAR LINE ESCAPE CHARACTER echo -en WHERE -e IS ALLOW INTERPRETAION OF BACKSLASH ESCAPE CHARACTERS AND -n IS SUPPRESS TRAILING NEWLINE. esc IS DECIMAL 27 OCTAL 033 HEX 0x1B C-ESCAPE \e AND CTRL-KEY ^[ . NOTE \e IS NOT GUARANTEED TO WORK IN ALL LANGUAGES AND COMPILERS. ESC[2K ERASE THE ENTIRE LINE (WILL NOT MOVE THE CURSOR - IT WILL REMAIN AT POSITION IT WAS AT BEFORE THE LINE WAS ERASED. USE \r CARRIAGE RETURN TO MOVE TOTHE START OF THE LINE). ALLOWS OVERWRITING OF LONGER rync OUTPUTS WHEN DIRECTORIES ARE CREATED AND FILES COPIED OR CHECKED. IE '\033[2k' AND '\e[2k' ARE EQUIVALENT ANSI ESCAPE SEQUENCES. THE CARRIAGE RETURN IS ACHEIVED WITH tr IN THE rsync COMMAND.
#  91-113)	if; then; elif; else; fi CONDITIONAL TO TEST OUT DIFFERENT rsync STRATEGIES BASED ON COMMAND LINE ARGUMENTS IN POSITIONAL PARAMETERS.
#  91)	IF SPECIAL PARAMETER REPRESENTING ALL POSITIONAL PARAMETERS CONTAINS THE STRING '--rsynca'
#  92)	IF TRUE THEN DO COMMANDS
#  93)	PRINT EXPLANATION OF rsync STRATEGY WHERE echo -e ENABLES BACKSLASH ESCAPE CHARACTERS AND '\eM' MOVES THE CURSOR UP ONE LINE OVERWRITING THE  PREVIOUS ECHO.
#  94)	THE rsync COMMAND TO MAKE THE DIRECTORY PATH AND COPY FILES TO THE WORKING DIRECTORY. THE OUTPUT IS PIPED THROUGH tr. THIS IS COMMAND TO TRANSLATE OR DELETE CHARACTERS AND IS USED TO REPLACE THE TRAILING newline ESCAPE CHARACTER FROM RSYNC OUTPUT WITH A CARRIAGE RETURN TO MAKE OUTPUT OVERWRITE ITSELF. THE COMMANDS ARE GROUPED WITHIN {} AND THEN PUT INTO THE BACKGROUND WITH & TERMINATOR, ALLOWING THE SECOND rsync TO CONTINUE ASYNCHRONOUSLY.
#		{ rsync --mkpath --info name2 -ah "/media/$USER/OLY_E-30/DCIM/100OLYMP/P421001.ORF" "/home/$USER/My Pictures/2024/raw images/04 Apr/2024_04_21/P421001.ORF"| tr '\n' '\r' }&
#		-- mkpath		CREATE DESTINATION'S MISSING PATH COMPONENTS
#		-- info name2		INFORMATION VERBOSITY
#		-h --human readable	OUTPUT NUMBERS IN HUMAN READABLE FORMAT
#		-a --archive		ARCHIVE MODE, IMPLIES
#						-r	RECURSIVE
#						-l	COPY LINKS
#						-p	PRESERVE PERMISSIONS
#						-t	PRESERVE MODIFICATION TIMES
#						-g	PRESERVE GROUP
#						-o	PRESERVE OWNER
#						-D	PRESERVE DEVICE / SPECIAL FILES
#  95)	rsync COMMAND FOR BACKUP DIRECTORY
#		rsync --mkpath --info name2 -ah "/media/$USER/OLY_E-30/DCIM/100OLYMP/P421001.ORF" "/medis/$USER/Backup_Data/My Pictures/2024/raw images/04 Apr/2024_04_21/P421001.ORF" | tr '\n' '\r'
#  96)	wait COMMAND PAUSES THE SCRIPT UNTIL ALL BACKGROUND PROCESSES COMPLETE.
#  97)	ELSE IF CONDITIONAL TO TEST FOR ARGUMENT '--rsyncb' IN POSITIONAL PARAMETERS
#  98)	IF TRUE THEN DO COMMANDS
#  99)	PRINT STRATEGY EXPLANATION
#  100)	rsync | tr COMMANDS FOR WORKING GROUPED WITH () AND THEREFORE RUN IN SUBSHELL THEN MOVED TO BACKGROUND WITH & TERMINATOR
#  101)	rsync | tr COMMANDS FOR BACKUP
#  102)	wait COMMAND PAUSES FOR ALL BACKGROUND TASKS
#  103)	ELSE IF CONDITIONAL TO TEST FOR ARGUMENT '--rsyncc' IN POSITIONAL PARAMETERS
#  104)	IF TRUE THEN DO COMMANDS
#  105)	PRINT STRATEGY EXPLANATION
#  106)	rsync | tr COMMANDS FOR WORKING THEN MOVED TO BACKGROUND WITH & TERMINATOR
#  107)	rsync | tr COMMANDS FOR BACKUP
#  108)	wait COMMAND PAUSES FOR ALL BACKGROUND TASKS
#  109)	ELSE IF CONDITIONAL TO TEST FOR ARGUMENT '--rsyncd' IN POSITIONAL PARAMETERS
#  110)	IF TRUE THEN DO COMMANDS
#  111)	PRINT STRATEGY EXPLANATION
#  112)	rsync | tr COMMANDS FOR WORKING GROUPED WITH {} THEN MOVED TO BACKGROUND WITH & TERMINATOR
#  113)	rsync | tr COMMANDS FOR BACKUP GROUPED WITH {} THEN MOVED TO BACKGROUND WITH & TERMINATOR

#  114)	ELSE IF FALSE THEN DO COMMANDS
#  115)	PRINT STRATEGY EXPLANATION
#  116)	rsync | tr COMMANDS FOR WORKING
#  117)	rsync | tr COMMANDS FOR BACKUP
#  118)	CLOSE IF BLOCK
#  120)	CREATE A LIST OF THE FILES TO BE COPIED WITH A NEWLINE $'\n' IN AN ARRAY BY USING FIND COMMAND TO CONFIRM COPY.
#  		find PATH -name PATTERN RETURNS FILENAME WITH PATH
#			-name TEST FOR BASE OF FILENAME (PATH REMOVED) TO MATCH PATTERN IN PATH
#		find "/media/$USER/OLY_E-30/DCIM/100OLYMP" -name "P421001.ORF"
#			/media/$USER/OLY_E-30/DCIM/100OLYMP/P421001.ORF
#		camera_file_list[1001]="/media/$USER/OLY_E-30/DCIM/100OLYMP/P421001.ORF"$'\n'
#  121)	CREATE A LIST OF THE FILES LOCATED ON WORKING SYSTEM WITH A NEWLINE $'\n' IN AN ARRAY BY USING FIND COMMAND
#		find "/home/$USER/My Pictures/2024/raw images/04 Apr/2024_04_21" -name "P421001.ORF"
#			/home/$USER/My Pictures/2024/raw images/04 Apr/2024_04_21/P421001.ORF
#		working_file_list[1001]="/home/$USER/My Pictures/2024/raw images/04 Apr/2024_04_21/P421001.ORF""$'\n'
#  122)	CREATE A LIST OF THE FILES LOCATED ON BACKUP SYSTEM WITH A NEWLINE $'\n' IN AN ARRAY BY USING FIND COMMAND
#		find "/media/$USER/Backup_Data/My Pictures/2024/raw images/04 Apr/2024_04_21" -name "P421001.ORF"
#			/media/$USER/Backup_Data/My Pictures/2024/raw images/04 Apr/2024_04_21/P421001.ORF
#		backup_file_list[1001]="/home/$USER/My Pictures/2024/raw images/04 Apr/2024_04_21/P421001.ORF""$'\n'
#  124)	USE SHELL ARITHMETIC TO ADD 2 TO THE VALUE OF loop2 AT END OF LOOP. ADDING TWO BECAUSE THE ARRAY CONTAINS ALTERNATING FILENAMES AND PATHS AND WE WANT TO MOVE TO NEXT FILENAME.
#		loop2 = loop2 + 2
#  126)	CLOSE LOOP2
#  128)	PRINT A BLANK LINE
#  129)	RESET THE $IFS DELIMETER SPECIAL PARAMETER TO DEFAULT VALUE STORED IN $old_IFS
#  130)	USE SHELL ARITHMETIC TO ADD 1000 TO THE VALUE OF loop1 AND RESET loop2 TO 0
#  131)	CLOSE LOOP1
#  133)	PRINT OUT A SUMMARY LIST OF FILES ON THE CAMERA USING SHELL PARAMETER EXPANSION TO REMOVE THE PATH FROM THE VARIABLE $camera_file_list[*]} ${ parameter##word } WHERE word IS PATTERN MATCHED TO parameter, IN THIS CASE THE VARIABLE $camera_dir.IF THE MATCH IS MADE TO THE BEGINNING OF parameter THE RESULT IS THE DELETION OF THE LONGEST MATCHING PATTERN. ${#name[*]} IS THE NUMBER OF ELEMENTS IN THE ARRAY camera_file_list
#		"${/media/$USER/OLY_E-30/DCIM/100OLYMP/P421001.ORF\n /media/$USER/OLY_E-30/DCIM/100OLYMP/P421002.ORF\n /media/$USER/OLY_E-30/DCIM/100OLYMP/P421003.ORF\n ## "/media/$USER/OLY_E-30/DCIM/100OLYMP/"}" ${# /media/$USER/OLY_E-30/DCIM/100OLYMP/P421001.ORF\n /media/$USER/OLY_E-30/DCIM/100OLYMP/P421002.ORF\n /media/$USER/OLY_E-30/DCIM/100OLYMP/P421003.ORF\n}
#			camera file list
#			 P421001.ORF
#			 P421002.ORF
#			 P421003.ORF
#			 3 files
#  134)	PRINT OUT A SUMMARY LIST OF FILES IN THE WORKING DIRECTORY WHERE ${#name[*]} IS THE NUMBER OF ELEMENTS IN THE ARRAY working_file_list
#		"${/home/$USER/My Pictures/2024/raw images/04 Apr/2024_04_21/P421001.ORF/n /home/$USER/My Pictures/2024/raw images/04 Apr/2024_04_21/P421002.ORF/n /home/$USER/My Pictures/2024/raw images/04 Apr/2024_04_21/P421003.ORF/n ## "/home/$USER/My Pictures/2024/raw images/04 Apr/2024_04_21/"}" ${# /home/$USER/My Pictures/2024/raw images/04 Apr/2024_04_21/P421001.ORF/n /home/$USER/My Pictures/2024/raw images/04 Apr/2024_04_21/P421002.ORF/n /home/$USER/My Pictures/2024/raw images/04 Apr/2024_04_21/P421003.ORF/n}
#			working file list
#			 ./working/2024/raw images/04 Apr/2024_04_21/P421001.ORF
#			 ./working/2024/raw images/04 Apr/2024_04_21/P421002.ORF
#			 ./working/2024/raw images/04 Apr/2024_04_21/P421003.ORF
#			 3 files
#  135)	PRINT OUT A SUMMARY LIST OF FILES IN THE BACKUP DIRECTORY WHERE ${#name[*]} IS THE NUMBER OF ELEMENTS IN THE ARRAY working_file_list
#		"${/media/$USER/Backup_Data/My Pictures/2024/raw images/04 Apr/2024_04_21/P421001.ORF/n /media/$USER/Backup_Data/My Pictures/2024/raw images/04 Apr/2024_04_21/P421002.ORF/n /media/$USER/Backup_Data/My Pictures/2024/raw images/04 Apr/2024_04_21/P421003.ORF/n ## "/media/$USER/Backup_Data/My Pictures/2024/raw images/04 Apr/2024_04_21"}" ${# /media/$USER/Backup_Data/My Pictures/2024/raw images/04 Apr/2024_04_21/P421001.ORF/n /media/$USER/Backup_Data/My Pictures/2024/raw images/04 Apr/2024_04_21/P421002.ORF/n /media/$USER/Backup_Data/My Pictures/2024/raw images/04 Apr/2024_04_21/P421003.ORF/n}
#			backup file list
#			 ./backup/2024/raw images/04 Apr/2024_04_21/P421001.ORF
#			 ./backup/2024/raw images/04 Apr/2024_04_21/P421002.ORF
#			 ./backup/2024/raw images/04 Apr/2024_04_21/P421003.ORF
#			 3 files
